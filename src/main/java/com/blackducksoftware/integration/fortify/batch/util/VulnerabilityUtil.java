/*
 * Copyright (C) 2017 Black Duck Software Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.
 *
 * The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.blackducksoftware.integration.fortify.batch.util;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.blackducksoftware.integration.exception.IntegrationException;
import com.blackducksoftware.integration.fortify.batch.model.Vulnerability;
import com.blackducksoftware.integration.fortify.hub.model.Recommendation;
import com.blackducksoftware.integration.hub.api.generated.enumeration.VulnerabilityWithRemediationSourceType;
import com.blackducksoftware.integration.hub.api.generated.view.VulnerableComponentView;

/**
 * This class will be used to have the common methods related to BlackDuck
 *
 * @author smanikantan
 *
 */
public final class VulnerabilityUtil {

    /**
     * It will be used to remove the duplicate vulnerabilities in the list
     *
     * @param vulnerabilities
     * @return
     */
    public static List<Vulnerability> removeDuplicates(final List<Vulnerability> vulnerabilities) {
        final Map<String, Vulnerability> uniqueKeys = new HashMap<>();
        // Iterate the vulnerabilities to remove the duplicates
        vulnerabilities.forEach(vulnerability -> {
            // The unique vulnerability will be the combination of Component name and version, Channel version and
            // Vulnerability Id
            final String uniqueKey = vulnerability.getComponentName() + "~" + vulnerability.getVersion() + "~" + vulnerability.getChannelVersionOriginId() + "~"
                    + vulnerability.getVulnerabilityId();

            // If the vulnerability is present in multiple project, then assign the project name and version name to
            // Multiple projects and Multiple versions respectively
            if (uniqueKeys.containsKey(uniqueKey)) {
                vulnerability = new Vulnerability("Multiple projects", "Multiple versions", vulnerability.getProjectId(), vulnerability.getVersionId(),
                        vulnerability.getChannelVersionId(), vulnerability.getComponentName(), vulnerability.getVersion(),
                        vulnerability.getChannelVersionOrigin(), vulnerability.getChannelVersionOriginId(), vulnerability.getChannelVersionOriginName(),
                        vulnerability.getVulnerabilityId(), vulnerability.getDescription(), vulnerability.getPublishedOn(), vulnerability.getUpdatedOn(),
                        vulnerability.getBaseScore(), vulnerability.getExploitability(), vulnerability.getImpact(), vulnerability.getVulnerabilitySource(),
                        vulnerability.getHubVulnerabilityUrl(), vulnerability.getRemediationStatus(), vulnerability.getRemediationTargetDate(),
                        vulnerability.getRemediationActualDate(), vulnerability.getRemediationComment(), vulnerability.getUrl(), vulnerability.getSeverity(),
                        vulnerability.getUpgradeVersion(), vulnerability.getUpgradeVersionReleasedOn(), vulnerability.getLatestVersion(),
                        vulnerability.getLatestVersionReleasedOn(), vulnerability.getScanDate());
            }
            uniqueKeys.put(uniqueKey, vulnerability);
        });
        return new ArrayList<>(uniqueKeys.values());
    }

    /**
     * It will convert Hub Component view to CSV Vulnerability view
     *
     * @param vulnerabilityComponentViews
     * @param hubProjectName
     * @param hubProjectVersion
     * @return List<Vulnerability>
     */
    public static List<Vulnerability> transformMapping(final HubServices hubServices, final List<VulnerableComponentView> vulnerabilityComponentViews,
            final String hubProjectName, final String hubProjectVersion, final Date maxBomUpdatedDate, final PropertyConstants propertyConstants)
            throws IntegrationException {
        final List<Vulnerability> vulnerabilities = new ArrayList<>();
        final Map<String, Recommendation> recommendations = new HashMap<>();
        for (final VulnerableComponentView vulnerableComponentView : vulnerabilityComponentViews) {
            final String remediatingUrl = vulnerableComponentView.componentVersion + "/remediating";
            Recommendation recommendation = null;
            if (recommendations.containsKey(remediatingUrl)) {
                recommendation = recommendations.get(remediatingUrl);
            } else {
                recommendation = hubServices.getComponentVersionRecommendations(remediatingUrl);
                recommendations.put(remediatingUrl, recommendation);
            }
            final String[] componentVersionLinkArr = vulnerableComponentView.componentVersion.split("/");
            final Vulnerability vulnerability = new Vulnerability(String.valueOf(hubProjectName),
                    String.valueOf(hubProjectVersion),
                    String.valueOf(componentVersionLinkArr[5]),
                    String.valueOf(componentVersionLinkArr[7]),
                    "",
                    String.valueOf(vulnerableComponentView.componentName),
                    String.valueOf(vulnerableComponentView.componentVersionName),
                    String.valueOf(vulnerableComponentView.componentVersionOriginName),
                    String.valueOf(vulnerableComponentView.componentVersionOriginId),
                    String.valueOf(vulnerableComponentView.componentVersionName),
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityName),
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.description.replaceAll("\\r\\n", "")),
                    vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityPublishedDate,
                    vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityUpdatedDate,
                    vulnerableComponentView.vulnerabilityWithRemediation.baseScore,
                    vulnerableComponentView.vulnerabilityWithRemediation.exploitabilitySubscore,
                    vulnerableComponentView.vulnerabilityWithRemediation.impactSubscore,
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.source.toString()),
                    propertyConstants.getHubServerUrl() + "/api/vulnerabilities/"
                            + String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityName),
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.remediationStatus.toString()),
                    vulnerableComponentView.vulnerabilityWithRemediation.remediationTargetAt,
                    vulnerableComponentView.vulnerabilityWithRemediation.remediationActualAt,
                    String.valueOf(""),
                    VulnerabilityWithRemediationSourceType.NVD.equals(vulnerableComponentView.vulnerabilityWithRemediation.source)
                            ? "http://web.nvd.nist.gov/view/vuln/detail?vulnId="
                                    + vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityName
                            : "",
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.severity.toString()),
                    recommendation != null && recommendation.getNoVulnerabilities() != null ? recommendation.getNoVulnerabilities().getName() : null,
                    recommendation != null && recommendation.getNoVulnerabilities() != null ? recommendation.getNoVulnerabilities().getReleasedOn() : null,
                    recommendation != null && recommendation.getLatestAfterCurrent() != null ? recommendation.getLatestAfterCurrent().getName() : null,
                    recommendation != null && recommendation.getLatestAfterCurrent() != null ? recommendation.getLatestAfterCurrent().getReleasedOn() : null,
                    maxBomUpdatedDate);
            vulnerabilities.add(vulnerability);
        }
        return vulnerabilities;
    }

    /**
     * Encode the input string
     *
     * @param URL
     * @return
     * @throws IOException
     */
    public static String encodeString(final String URL) throws IOException {

        String urlString = "";
        try {
            urlString = URLEncoder.encode(URL, "UTF-8");
        } catch (final UnsupportedEncodingException e) {
            throw new IOException(e);
        }

        return urlString;

    }
}
