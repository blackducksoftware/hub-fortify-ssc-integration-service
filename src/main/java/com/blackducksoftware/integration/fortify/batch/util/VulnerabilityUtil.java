/*
 * Copyright (C) 2017 Black Duck Software Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.
 *
 * The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.blackducksoftware.integration.fortify.batch.util;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.blackducksoftware.integration.fortify.batch.model.Vulnerability;
import com.blackducksoftware.integration.hub.model.view.VulnerableComponentView;

/**
 * This class will be used to have the common methods related to BlackDuck
 *
 * @author smanikantan
 *
 */
public final class VulnerabilityUtil {

    /**
     * It will be used to remove the duplicate vulnerabilities in the list
     *
     * @param vulnerabilities
     * @return
     */
    public static List<Vulnerability> removeDuplicates(List<Vulnerability> vulnerabilities) {
        Map<String, Vulnerability> uniqueKeys = new HashMap<>();
        // Iterate the vulnerabilities to remove the duplicates
        vulnerabilities.forEach(vulnerability -> {
            // The unique vulnerability will be the combination of Component name and version, Channel version and
            // Vulnerability Id
            String uniqueKey = vulnerability.getComponentName() + "~" + vulnerability.getVersion() + "~" + vulnerability.getChannelVersionOriginId() + "~"
                    + vulnerability.getVulnerabilityId();

            // If the vulnerability is present in multiple project, then assign the project name and version name to
            // Multiple projects and Multiple versions respectively
            if (uniqueKeys.containsKey(uniqueKey)) {
                vulnerability = new Vulnerability("Multiple projects", "Multiple versions", vulnerability.getProjectId(), vulnerability.getVersionId(),
                        vulnerability.getChannelVersionId(), vulnerability.getComponentName(), vulnerability.getVersion(),
                        vulnerability.getChannelVersionOrigin(), vulnerability.getChannelVersionOriginId(), vulnerability.getChannelVersionOriginName(),
                        vulnerability.getVulnerabilityId(), vulnerability.getDescription(), vulnerability.getPublishedOn(), vulnerability.getUpdatedOn(),
                        vulnerability.getBaseScore(), vulnerability.getExploitability(), vulnerability.getImpact(), vulnerability.getVulnerabilitySource(),
                        vulnerability.getHubVulnerabilityUrl(), vulnerability.getRemediationStatus(), vulnerability.getRemediationTargetDate(),
                        vulnerability.getRemediationActualDate(), vulnerability.getRemediationComment(), vulnerability.getUrl(), vulnerability.getSeverity(),
                        vulnerability.getScanDate());
            }
            uniqueKeys.put(uniqueKey, vulnerability);
        });
        return new ArrayList<>(uniqueKeys.values());
    }

    /**
     * It will convert Hub Component view to CSV Vulnerability view
     *
     * @param vulnerabilityComponentViews
     * @param hubProjectName
     * @param hubProjectVersion
     * @return List<Vulnerability>
     */
    public static List<Vulnerability> transformMapping(List<VulnerableComponentView> vulnerabilityComponentViews, String hubProjectName,
            String hubProjectVersion, Date maxBomUpdatedDate, PropertyConstants propertyConstants) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        vulnerabilityComponentViews.forEach(vulnerableComponentView -> {
            String[] componentVersionLinkArr = vulnerableComponentView.componentVersionLink.split("/");
            Vulnerability vulnerability = new Vulnerability(String.valueOf(hubProjectName),
                    String.valueOf(hubProjectVersion),
                    String.valueOf(componentVersionLinkArr[5]),
                    String.valueOf(componentVersionLinkArr[7]),
                    "",
                    String.valueOf(vulnerableComponentView.componentName),
                    String.valueOf(vulnerableComponentView.componentVersionName),
                    String.valueOf(vulnerableComponentView.componentVersionOriginName),
                    String.valueOf(vulnerableComponentView.componentVersionOriginId),
                    String.valueOf(vulnerableComponentView.componentVersionName),
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityName),
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.description.replaceAll("\\r\\n", "")),
                    vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityPublishedDate,
                    vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityUpdatedDate,
                    vulnerableComponentView.vulnerabilityWithRemediation.baseScore,
                    vulnerableComponentView.vulnerabilityWithRemediation.exploitabilitySubscore,
                    vulnerableComponentView.vulnerabilityWithRemediation.impactSubscore,
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.source),
                    propertyConstants.getHubServerUrl() + "/ui/vulnerabilities/id:"
                            + String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityName) + "/view:overview",
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.remediationStatus),
                    vulnerableComponentView.vulnerabilityWithRemediation.remediationTargetAt,
                    vulnerableComponentView.vulnerabilityWithRemediation.remediationActualAt,
                    String.valueOf(""),
                    "NVD".equalsIgnoreCase(vulnerableComponentView.vulnerabilityWithRemediation.source)
                            ? "http://web.nvd.nist.gov/view/vuln/detail?vulnId="
                                    + vulnerableComponentView.vulnerabilityWithRemediation.vulnerabilityName
                            : "",
                    String.valueOf(vulnerableComponentView.vulnerabilityWithRemediation.severity),
                    maxBomUpdatedDate);
            vulnerabilities.add(vulnerability);
        });
        return vulnerabilities;
    }
}
